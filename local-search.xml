<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>软件打开</title>
    <link href="/2024/01/23/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%BC%80/"/>
    <url>/2024/01/23/%E8%BD%AF%E4%BB%B6%E6%89%93%E5%BC%80/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>aws名词解释</title>
    <link href="/2024/01/17/aws%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    <url>/2024/01/17/aws%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="IAM"><a href="#IAM" class="headerlink" title="IAM"></a>IAM</h1><p>AWS Identity and Access Management (IAM) 是一种 Web 服务，可以帮助您安全地控制对 AWS 资源的访问。借助 IAM，您可以集中管理控制用户可访问哪些 AWS 资源的权限。可以使用 IAM 来控制谁通过了身份验证（准许登录）并获得授权（拥有权限）来使用资源。</p><p>当您创建 AWS 账户时，最初使用的是一个对账户中所有 AWS 服务和资源拥有完全访问权限的登录身份。此身份称为 AWS 账户<em>根用户</em>，使用您创建账户时所用的电子邮件地址和密码登录，即可获得该身份。强烈建议您不要使用根用户执行日常任务。保护好根用户凭证，并使用这些凭证来执行仅根用户可以执行的任务。有关需要您以根用户身份登录的任务的完整列表，请参阅</p><h1 id="Amazon-S3"><a href="#Amazon-S3" class="headerlink" title="Amazon S3"></a>Amazon S3</h1><p>Amazon Simple Storage Service（Amazon S3）是一种对象存储服务，提供行业领先的可扩展性、数据可用性、安全性和性能。各种规模和行业的客户都可以使用 Amazon S3 存储和保护任意数量的数据，用于数据湖、网站、移动应用程序、备份和恢复、归档、企业应用程序、IoT 设备和大数据分析。Amazon S3 提供了管理功能，使您可以优化、组织和配置对数据的访问，以满足您的特定业务、组织和合规性要求。</p><h1 id="AWS-DataSync"><a href="#AWS-DataSync" class="headerlink" title="AWS DataSync"></a>AWS DataSync</h1><p>AWS DataSync是一项在线数据移动和发现服务，可简化数据迁移，并帮助您在AWS存储服务之间快速、轻松、安全地传输文件或对象数据。</p><p>DataSync使用以下存储系统和服务：</p><ul><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-nfs-location.html">网络文件系统（NFS）</a>文件服务器</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-smb-location.html">服务器消息块（SMB）</a>文件服务器</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-hdfs-location.html">Hadoop Distributed File</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-object-location.html">对象存储</a>系统</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-s3-location.html">Amazon S3</a> 存储桶</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-efs-location.html">亚马逊 EFS</a> 文件系统</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-fsx-location.html">Amazon FSx for Windows File Server 文件</a>系统</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-lustre-location.html">Amazon FSx for Lustre</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-openzfs-location.html">Amazon FSx for OpenZ</a> FS 文件系统</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/create-ontap-location.html">适用于 NetApp ONTAP 文件系统的亚马逊 FSx</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/tutorial_transfer-google-cloud-storage.html">Good Storag</a> e</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/creating-azure-blob-location.html">微软 Azure Bloud Storag</a> e</li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/transferring-azure-files.html">微软 Azure 文件</a></li><li>AWS Snowball Edge设备@@ <a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/s3-compatible-storage-snow.html">上兼容Amazon S3 的存储</a></li><li><a href="https://docs.aws.amazon.com/zh_cn/datasync/latest/userguide/nfs-on-snowcone.html">AWS Snowcone</a> 设备</li></ul><h1 id="Amazon-EventBridge"><a href="#Amazon-EventBridge" class="headerlink" title="Amazon EventBridge"></a>Amazon EventBridge</h1><p>使用 Kinesis 数据流，您可以将 AWS API 调用<a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-events.html">事件</a>发送EventBridge到数据流、构建消费者应用程序和处理大量数据。您还可以在 Pipes 中使用 Kinesis Data Streams 作为 Pipes 中的EventBridge目标，并在可选的筛选和丰富后将记录传送到来自可用源之一的流中。</p><p>有关更多信息，请参阅亚马逊<em>EventBridge用户指南</em>中的<a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-relay-events-kinesis-stream.html">将事件发送到亚马逊 Kinesis 直播</a>和<a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-pipes.html">EventBridge管道</a>。</p><h1 id="Amazon-ECS"><a href="#Amazon-ECS" class="headerlink" title="Amazon ECS"></a><strong>Amazon ECS</strong></h1><p>Amazon Elastic Container Service（ECS）是一项完全托管的容器编排服务，可帮助您更有效地部署、管理和扩展容器化的应用程序。它与 AWS 环境深度集成，提供易于使用的解决方案，用于在云端和本地运行容器工作负载，并通过 Amazon ECS Anywhere 提供高级安全功能。</p><h1 id="Amazon-Elastic-File-System（Amazon-EFS）"><a href="#Amazon-Elastic-File-System（Amazon-EFS）" class="headerlink" title="Amazon Elastic File System（Amazon EFS）"></a>Amazon Elastic File System（Amazon EFS）</h1><p>Amazon Elastic File System（Amazon EFS）提供无服务器的完全弹性文件存储，因此，您无需预置或管理存储容量和性能，即可共享文件数据。Amazon EFS 可在不中断应用程序的情况下按需扩展到 PB 级，并且在您添加和删除文件时会自动增长和缩小。由于 Amazon EFS 具有简单的 Web 服务接口，因此您可以快速轻松地创建和配置文件系统。该服务为您管理所有文件存储基础设施，这意味着您可以避免部署、修补和维护复杂文件系统配置的复杂性。</p><p>Amazon EFS 支持网络文件系统版本 4（NFSv4.1 和 NFSv4.0）协议，因此您目前使用的应用程序和工具可与 Amazon EFS 无缝协作。多个计算实例，包括 Amazon EC2、Amazon ECS 和AWS Lambda，可以同时访问一个 Amazon EFS 文件系统。因此，EFS 文件系统可以为在多个计算实例或服务器上运行的工作负载和应用程序提供通用数据源。</p><h1 id="Amazon-EMR-Serverless"><a href="#Amazon-EMR-Serverless" class="headerlink" title="Amazon EMR Serverless"></a>Amazon EMR Serverless</h1><p>Amazon EMR Serverless 是 Amazon EMR 中的一个新选项，它使数据工程师和分析师能够轻松且成本高效地运行使用开源大数据框架（例如 Apache Spark、Hive 或 Presto）构建的应用程序，而无需调整、运营、优化、保护或管理集群。</p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><h3 id="执行大数据分析"><a href="#执行大数据分析" class="headerlink" title="执行大数据分析"></a>执行大数据分析</h3><p>使用统计算法和预测性模型运行大规模数据处理和 what-if 分析，发现隐藏的模式、相关性、市场趋势和客户偏好。</p><h3 id="构建可扩展的数据管道"><a href="#构建可扩展的数据管道" class="headerlink" title="构建可扩展的数据管道"></a>构建可扩展的数据管道</h3><p>从各种来源中提取数据、大规模处理数据，并将数据提供给应用程序和用户。</p><h3 id="处理实时数据流"><a href="#处理实时数据流" class="headerlink" title="处理实时数据流"></a>处理实时数据流</h3><p>实时分析来自流式数据源的事件，以创建长期运行、高度可用且具有容错能力的流式数据管道。</p><h3 id="加速数据科学和-ML-采用"><a href="#加速数据科学和-ML-采用" class="headerlink" title="加速数据科学和 ML 采用"></a>加速数据科学和 ML 采用</h3><p>使用 Apache Spark MLlib、TensorFlow 和 Apache MXNet 等开源 ML 框架。连接 Amazon SageMaker Studio 进行大型模型训练、分析和报告。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu22 Mysql GUI工具安装</title>
    <link href="/2024/01/09/ubuntu22-Mysql-GUI%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    <url>/2024/01/09/ubuntu22-Mysql-GUI%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装mysql"><a href="#1-安装mysql" class="headerlink" title="1 安装mysql"></a>1 安装mysql</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">$ sudo apt update<br>$ sudo apt install mysql-server -y<br>#安装完成后，MySQL 守护进程就会自动启动并在后台安静运行，通过下命令来确认<br>$ sudo systemctl status mysql<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/image-20240109173356768.png" alt="image-20240109173356768"></p><p>也可以通过以下命令确认</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ systemctl is-active mysql<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/image-20240109173440770.png" alt="image-20240109173440770"></p><h2 id="1-2-基础设置"><a href="#1-2-基础设置" class="headerlink" title="1.2 基础设置"></a>1.2 基础设置</h2><p>MySQL 安装提供了一个安全脚本，用于解决不太安全的默认选项，请运行以下命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ sudo mysql_secure_installation<br></code></pre></td></tr></table></figure><p>默认情况下，MySQL 使用 auth_socket 进行身份验证。这是一种无密码身份验证，使用 auth_socket 插件，用户可以使用其用户帐户凭据登录 MySQL 并对其进行身份验证。</p><h3 id="1-2-1-设置密码登陆"><a href="#1-2-1-设置密码登陆" class="headerlink" title="1.2.1 设置密码登陆"></a>1.2.1 设置密码登陆</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo mysql<br></code></pre></td></tr></table></figure><p>接下来，运行 ALTER USER 命令将 root 用户的身份验证方法修改为密码验证，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;mypassword&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/image-20240109175933686.png" alt="image-20240109175933686"></p><p>然后，退出 MySQL 终端</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">FLUSH PRIVILEGES<br>EXIT<br></code></pre></td></tr></table></figure><p>再次运行脚本，提供 root 密码，然后按 ENTER。接下来，您可以选择更改 root 用户的密码或提供新密码。在我们的情况下，我们不修改密码，因此，我们将按 N。</p><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/image-20240109180218313.png" alt="image-20240109180218313"></p><h3 id="1-2-2-创建管理用户"><a href="#1-2-2-创建管理用户" class="headerlink" title="1.2.2 创建管理用户"></a>1.2.2 创建管理用户</h3><h3 id="4-创建-MySQL-管理用户"><a href="#4-创建-MySQL-管理用户" class="headerlink" title="(4) 创建 MySQL 管理用户"></a>(4) 创建 MySQL 管理用户</h3><p>默认情况下，MySQL 会在安装期间创建一个默认的根用户来管理数据库。用户拥有完全权限，因此可以对所有数据库、表、用户等进行绝对控制。</p><p>建议为运行管理任务创建一个单独的数据库用户，再次以 root 用户身份登录 MySQL 数据库服务器。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ sudo mysql -u root -p<br></code></pre></td></tr></table></figure><p>创建数据库用户</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">CREATE USER &#x27;linuxtechi&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;<br></code></pre></td></tr></table></figure><p>然后将所有权限授予用户，*.* 表示数据库服务器中的所有数据库。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">GRANT ALL PRIVILEGES ON *.* TO &#x27;linuxtechi&#x27;@&#x27;localhost&#x27; WITH GRANT OPTION;<br></code></pre></td></tr></table></figure><p>接下来，刷新PRIVILEGES</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">FLUSH PRIVILEGES<br></code></pre></td></tr></table></figure><p>退出 MySQL 终端</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">EXIT<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/image-20240109180508522.png" alt="image-20240109180508522"></p><p>测试</p><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/image-20240109180540322.png" alt="image-20240109180540322"></p><h1 id="2-图形化界面"><a href="#2-图形化界面" class="headerlink" title="2 图形化界面"></a>2 图形化界面</h1><p>选择MySQL Workbench</p><p><a href="https://dev.mysql.com/downloads/workbench/">https://dev.mysql.com/downloads/workbench/</a></p><p>不太清楚第一个第二个的区别，下载第一个能用。</p><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/image-20240110102037476.png" alt="image-20240110102037476"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git与远程仓库配置SSH加密</title>
    <link href="/2024/01/05/git%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AESSH%E5%8A%A0%E5%AF%86/"/>
    <url>/2024/01/05/git%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AESSH%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Git与远程仓库GitHub配置SSH加密"><a href="#Git与远程仓库GitHub配置SSH加密" class="headerlink" title="Git与远程仓库GitHub配置SSH加密"></a>Git与远程仓库GitHub配置SSH加密</h2><p><strong>一、下载安装Git</strong></p><p>直接到官网下载git即可，git的环境变量会随着下载安装自动添加</p><p><strong>二、给本地和远程仓库配置SSH</strong></p><p> 每台计算机上只需要配置一次</p><p><strong>（1）设置用户名和邮件地址</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span>  user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;这里换上你的用户名&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;这里换上你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>提示：如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p><p><strong>（2）生成 SSH 公钥</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;这里换上你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><ol><li>确认秘钥的保存路径（如果不需要改路径则直接回车）；</li><li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；</li><li>创建密码（如果不需要密码则直接回车）</li></ol><p><strong>(3)与GitHub设置ssh配对</strong></p><p>在上述指定的保存路径下会生成2个名为id_rsa和id_rsa.pub的文件，将生成的id_rsa.pub文件，把内容拷贝到key下面的输入框，并为这个key定义一个名称（通常用来区分不同主机），然后保存</p><p><strong><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/1570201-20200609015741571-2147040634.jpg" alt="img"><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/ubuntu_typora_img/1570201-20200609015956385-1218214873.jpg" alt="img"></strong></p><p>注意：秘钥对：<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p><strong>三、配置过程中可以用来检验的一些命令或操作</strong></p><p>（1）查看当前用户名和邮箱：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">git config</span> <span class="hljs-literal">--</span><span class="hljs-comment">global</span>  <span class="hljs-literal">--</span><span class="hljs-comment">list</span><br></code></pre></td></tr></table></figure><p>（2）查看当前本地与GitHub的连接情况：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bilibili验证码验证</title>
    <link href="/2023/12/21/bilibili%E9%AA%8C%E8%AF%81%E7%A0%81%E9%AA%8C%E8%AF%81/"/>
    <url>/2023/12/21/bilibili%E9%AA%8C%E8%AF%81%E7%A0%81%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>验证码</p><p>tujian</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-comment"># 一、图片文字类型(默认 3 数英混合)：</span><br><span class="hljs-comment"># 1 : 纯数字</span><br><span class="hljs-comment"># 1001：纯数字2</span><br><span class="hljs-comment"># 2 : 纯英文</span><br><span class="hljs-comment"># 1002：纯英文2</span><br><span class="hljs-comment"># 3 : 数英混合</span><br><span class="hljs-comment"># 1003：数英混合2</span><br><span class="hljs-comment">#  4 : 闪动GIF</span><br><span class="hljs-comment"># 7 : 无感学习(独家)</span><br><span class="hljs-comment"># 11 : 计算题</span><br><span class="hljs-comment"># 1005:  快速计算题</span><br><span class="hljs-comment"># 16 : 汉字</span><br><span class="hljs-comment"># 32 : 通用文字识别(证件、单据)</span><br><span class="hljs-comment"># 66:  问答题</span><br><span class="hljs-comment"># 49 :recaptcha图片识别</span><br><span class="hljs-comment"># 二、图片旋转角度类型：</span><br><span class="hljs-comment"># 29 :  旋转类型</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 三、图片坐标点选类型：</span><br><span class="hljs-comment"># 19 :  1个坐标</span><br><span class="hljs-comment"># 20 :  3个坐标</span><br><span class="hljs-comment"># 21 :  3 ~ 5个坐标</span><br><span class="hljs-comment"># 22 :  5 ~ 8个坐标</span><br><span class="hljs-comment"># 27 :  1 ~ 4个坐标</span><br><span class="hljs-comment"># 48 : 轨迹类型</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 四、缺口识别</span><br><span class="hljs-comment"># 18 : 缺口识别（需要2张图 一张目标图一张缺口图）</span><br><span class="hljs-comment"># 33 : 单缺口识别（返回X轴坐标 只需要1张图）</span><br><span class="hljs-comment"># 五、拼图识别</span><br><span class="hljs-comment"># 53：拼图识别</span><br><span class="hljs-comment">#函数实现忽略</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">base64_api</span>(<span class="hljs-params">uname, pwd, img, typeid</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(img, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        base64_data = base64.b64encode(f.read())<br>        b64 = base64_data.decode()<br>    data = &#123;<span class="hljs-string">&quot;username&quot;</span>: uname, <span class="hljs-string">&quot;password&quot;</span>: pwd, <span class="hljs-string">&quot;typeid&quot;</span>: typeid, <span class="hljs-string">&quot;image&quot;</span>: b64&#125;<br>    result = json.loads(requests.post(<span class="hljs-string">&quot;http://api.ttshitu.com/predict&quot;</span>, json=data).text)<br>    <span class="hljs-keyword">if</span> result[<span class="hljs-string">&#x27;success&#x27;</span>]:<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;result&quot;</span>]<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> result[<span class="hljs-string">&quot;message&quot;</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getImgCodeText</span>(<span class="hljs-params">imgPath,imgType</span>):<span class="hljs-comment">#直接返回验证码内容</span><br>    <span class="hljs-comment">#imgPath：验证码图片地址</span><br>    <span class="hljs-comment">#imgType：验证码图片类型</span><br>    result = base64_api(uname=<span class="hljs-string">&#x27;xxx&#x27;</span>, pwd=<span class="hljs-string">&#x27;xxx&#x27;</span>, img=imgPath, typeid=imgType)<br>    <span class="hljs-keyword">return</span> result<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver <span class="hljs-keyword">import</span> ActionChains<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><span class="hljs-keyword">import</span> tujian<br><span class="hljs-comment">#1.创建浏览器对象</span><br>bro = webdriver.Chrome(executable_path=<span class="hljs-string">&#x27;./chromedriver&#x27;</span>)<br><span class="hljs-comment">#2.发起请求</span><br>login_url = <span class="hljs-string">&#x27;https://passport.bilibili.com/login?from_spm_id=333.851.top_bar.login_window&#x27;</span><br>bro.get(login_url)<br>sleep(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#3.定位到指定标签填充用户名和密码</span><br>user_box = bro.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;app&quot;]/div[2]/div[2]/div[3]/div[2]/div[1]/div[1]/input&#x27;</span>)<br>user_box.send_keys(<span class="hljs-string">&#x27;&#x27;</span>)<br>sleep(<span class="hljs-number">1</span>)<br>pwd_box = bro.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;app&quot;]/div[2]/div[2]/div[3]/div[2]/div[1]/div[3]/input&#x27;</span>)<br>pwd_box.send_keys(<span class="hljs-string">&#x27;&#x27;</span>)<br>sleep(<span class="hljs-number">1</span>)<br>login_btn = bro.find_element_by_xpath(<span class="hljs-string">&#x27;//*[@id=&quot;app&quot;]/div[2]/div[2]/div[3]/div[2]/div[2]/div[2]&#x27;</span>)<br>login_btn.click()<br>sleep(<span class="hljs-number">10</span>)<br><span class="hljs-comment">#4.定位完整的验证码对话框</span><br><span class="hljs-comment">#注意：在开发者工具中是可以定位到多个div表示验证码对话框的，因此将这几个div都定位到，以此去尝试</span><br>code_tag = bro.find_element_by_xpath(<span class="hljs-string">&#x27;/html/body/div[4]/div[2]/div[6]/div/div&#x27;</span>)<br>sleep(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#5.识别验证码（使用打码平台进行验证码识别）</span><br>code_tag.screenshot(<span class="hljs-string">&#x27;./code.png&#x27;</span>)<span class="hljs-comment">#将验证码对话框截图保存</span><br>sleep(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#使用图鉴接口识别</span><br>result = tujian.getImgCodeText(<span class="hljs-string">&#x27;./code.png&#x27;</span>,<span class="hljs-number">27</span>)<span class="hljs-comment">#获取了识别的结果</span><br><span class="hljs-comment"># result = &#x27;154,251|145,167&#x27;</span><br><span class="hljs-comment"># print(result)</span><br>result_list = result.split(<span class="hljs-string">&#x27;|&#x27;</span>)<br><span class="hljs-comment">#result_list == [&#x27;154,251&#x27;,&#x27;145,167&#x27;]</span><br><span class="hljs-comment">#6.根据识别出验证码的结果进行处理</span><br><span class="hljs-keyword">for</span> pos <span class="hljs-keyword">in</span> result_list:<br>    x = <span class="hljs-built_in">int</span>(pos.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>])<br>    y = <span class="hljs-built_in">int</span>(pos.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>])<br>    ActionChains(bro).move_to_element_with_offset(code_tag,x,y).click().perform()<br>    sleep(<span class="hljs-number">0.5</span>)<br>sleep(<span class="hljs-number">2</span>)<br><span class="hljs-comment">#此处使用class属性进行确定标签定位</span><br>confirm_btn = bro.find_element_by_xpath(<span class="hljs-string">&#x27;//a[@class=&quot;geetest_commit&quot;]&#x27;</span>)<br>confirm_btn.click()<br>sleep(<span class="hljs-number">3</span>)<br>bro.quit()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>爬虫逆向滑块验证</title>
    <link href="/2023/12/21/%E7%88%AC%E8%99%AB%E9%80%86%E5%90%91%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81/"/>
    <url>/2023/12/21/%E7%88%AC%E8%99%AB%E9%80%86%E5%90%91%E6%BB%91%E5%9D%97%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="selenium滑动验证"><a href="#selenium滑动验证" class="headerlink" title="selenium滑动验证"></a>selenium滑动验证</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By  <span class="hljs-comment"># 按照什么方式查找，By.ID,By.CSS_SELECTOR</span><br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait  <span class="hljs-comment"># 等待页面加载某些元素</span><br><span class="hljs-keyword">import</span> cv2 <span class="hljs-comment">#pip install opencv-python</span><br><br><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request<br><span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<br><br><br><span class="hljs-comment">#获取要滑动的距离</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_distance</span>():<br>    <span class="hljs-comment">#滑动验证码的整体背景图片</span><br>    background = cv2.imread(<span class="hljs-string">&quot;background.png&quot;</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">#缺口图片</span><br>    gap = cv2.imread(<span class="hljs-string">&quot;gap.png&quot;</span>, <span class="hljs-number">0</span>)<br><br>    res = cv2.matchTemplate(background, gap, cv2.TM_CCOEFF_NORMED)<br>    value = cv2.minMaxLoc(res)[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">print</span>(value)<br>    <span class="hljs-comment">#单位换算</span><br>    <span class="hljs-keyword">return</span> value * <span class="hljs-number">278</span> / <span class="hljs-number">360</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    chrome = webdriver.Chrome(executable_path=<span class="hljs-string">&#x27;./chromedriver&#x27;</span>)<br>    chrome.implicitly_wait(<span class="hljs-number">5</span>)<br><br>    chrome.get(<span class="hljs-string">&#x27;https://passport.jd.com/new/login.aspx?&#x27;</span>)<br><br>    login = chrome.find_element(By.ID, <span class="hljs-string">&#x27;pwd-login&#x27;</span>)<br>    login.click()<br><br>    loginname = chrome.find_element(By.ID, <span class="hljs-string">&#x27;loginname&#x27;</span>)<br>    loginname.send_keys(<span class="hljs-string">&quot;xxxx&quot;</span>)<br><br>    nloginpwd = chrome.find_element(By.ID, <span class="hljs-string">&#x27;nloginpwd&#x27;</span>)<br>    nloginpwd.send_keys(<span class="hljs-string">&quot;xxxxx&quot;</span>)<br><br>    loginBtn = chrome.find_element(By.CLASS_NAME, <span class="hljs-string">&#x27;login-btn&#x27;</span>)<br>    loginBtn.click()<br>    <span class="hljs-comment">#带缺口的大图</span><br>    img_src = chrome.find_element(By.XPATH, <span class="hljs-string">&#x27;//*[@class=&quot;JDJRV-bigimg&quot;]/img&#x27;</span>).get_attribute(<span class="hljs-string">&quot;src&quot;</span>)<br>    <span class="hljs-comment">#缺口图片</span><br>    temp_src = chrome.find_element(By.XPATH, <span class="hljs-string">&#x27;//*[@class=&quot;JDJRV-smallimg&quot;]/img&#x27;</span>).get_attribute(<span class="hljs-string">&quot;src&quot;</span>)<br>    <span class="hljs-comment">#两张图片保存起来</span><br>    request.urlretrieve(img_src, <span class="hljs-string">&quot;background.png&quot;</span>)<br>    request.urlretrieve(temp_src, <span class="hljs-string">&quot;gap.png&quot;</span>)<br><br>    distance = <span class="hljs-built_in">int</span>(get_distance())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;distance:&quot;</span>, distance)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第一步,点击滑动按钮&#x27;</span>)<br>    element = chrome.find_element(By.CLASS_NAME, <span class="hljs-string">&#x27;JDJRV-slide-btn&#x27;</span>)<br>    ActionChains(chrome).click_and_hold(on_element=element).perform()  <span class="hljs-comment"># 点击鼠标左键，按住不放</span><br><br>    ActionChains(chrome).move_by_offset(xoffset=distance, yoffset=<span class="hljs-number">0</span>).perform()<br>    ActionChains(chrome).release(on_element=element).perform()<br><br>    time.sleep(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h1 id="pyppeteer滑动验证"><a href="#pyppeteer滑动验证" class="headerlink" title="pyppeteer滑动验证"></a>pyppeteer滑动验证</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_track</span>():<br>    background = cv2.imread(<span class="hljs-string">&quot;background.png&quot;</span>, <span class="hljs-number">0</span>)<br>    gap = cv2.imread(<span class="hljs-string">&quot;gap.png&quot;</span>, <span class="hljs-number">0</span>)<br><br>    res = cv2.matchTemplate(background, gap, cv2.TM_CCOEFF_NORMED)<br>    value = cv2.minMaxLoc(res)[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> value * <span class="hljs-number">278</span> / <span class="hljs-number">360</span> - <span class="hljs-number">13</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-comment"># headless指定浏览器是否以无头模式运行，默认是True。</span><br>        <span class="hljs-string">&quot;headless&quot;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-comment">#设置窗口大小</span><br>        <span class="hljs-string">&quot;args&quot;</span>: [<span class="hljs-string">&#x27;--window-size=1366,768&#x27;</span>],<br>        <span class="hljs-string">&quot;executablePath&quot;</span> : <span class="hljs-string">&#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;</span><br>    &#125;)<br>    <span class="hljs-comment"># 打开新的标签页</span><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-comment"># 设置页面大小一致</span><br>    <span class="hljs-keyword">await</span> page.setViewport(&#123;<span class="hljs-string">&quot;width&quot;</span>: <span class="hljs-number">1366</span>, <span class="hljs-string">&quot;height&quot;</span>: <span class="hljs-number">768</span>&#125;)<br>    <span class="hljs-comment"># 访问主页</span><br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&quot;https://passport.jd.com/new/login.aspx?&quot;</span>)<br><br><br>    <span class="hljs-comment"># 模拟输入用户名和密码,输入每个字符的间隔时间delay ms</span><br>    <span class="hljs-keyword">await</span> page.<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;#loginname&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>, &#123;<br>        <span class="hljs-string">&quot;delay&quot;</span>: random.randint(<span class="hljs-number">30</span>, <span class="hljs-number">60</span>)<br>    &#125;)<br>    <span class="hljs-keyword">await</span> page.<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;#nloginpwd&quot;</span>, <span class="hljs-string">&#x27;&#x27;</span>, &#123;<br>        <span class="hljs-string">&quot;delay&quot;</span>: random.randint(<span class="hljs-number">30</span>, <span class="hljs-number">60</span>)<br>    &#125;)<br><br>    <span class="hljs-comment"># page.waitFor 通用等待方式，如果是数字，则表示等待具体时间（毫秒）: 等待2秒</span><br>    <span class="hljs-keyword">await</span> page.waitFor(<span class="hljs-number">2000</span>)<br>    <span class="hljs-keyword">await</span> page.click(<span class="hljs-string">&quot;div.login-btn&quot;</span>)<br>    <span class="hljs-keyword">await</span> page.waitFor(<span class="hljs-number">2000</span>)<br>    <span class="hljs-comment"># page.Jeval（selector，pageFunction）#定位元素，并调用js函数去执行</span><br>    <span class="hljs-comment">#=&gt;表示js的箭头函数：el = function(el)&#123;return el.src&#125;</span><br>    img_src = <span class="hljs-keyword">await</span> page.Jeval(<span class="hljs-string">&quot;.JDJRV-bigimg &gt; img&quot;</span>, <span class="hljs-string">&quot;el=&gt;el.src&quot;</span>)<br>    temp_src = <span class="hljs-keyword">await</span> page.Jeval(<span class="hljs-string">&quot;.JDJRV-smallimg &gt; img&quot;</span>, <span class="hljs-string">&quot;el=&gt;el.src&quot;</span>)<br><br>    request.urlretrieve(img_src, <span class="hljs-string">&quot;background.png&quot;</span>)<br>    request.urlretrieve(temp_src, <span class="hljs-string">&quot;gap.png&quot;</span>)<br><br>    <span class="hljs-comment"># 获取gap的距离</span><br>    distance = <span class="hljs-keyword">await</span> get_track()<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # Pyppeteer 三种解析方式</span><br><span class="hljs-string">        Page.querySelector()  # 选择器</span><br><span class="hljs-string">        Page.querySelectorAll()</span><br><span class="hljs-string">        Page.xpath()  # xpath  表达式</span><br><span class="hljs-string">        # 简写方式为：</span><br><span class="hljs-string">        Page.J(), Page.JJ(), and Page.Jx()</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#定位到滑动按钮标签</span><br>    el = <span class="hljs-keyword">await</span> page.J(<span class="hljs-string">&quot;div.JDJRV-slide-btn&quot;</span>)<br>    <span class="hljs-comment"># 获取元素的边界框，包含x,y坐标</span><br>    box = <span class="hljs-keyword">await</span> el.boundingBox()<br>    <span class="hljs-comment">#box=&#123;&#x27;x&#x27;: 86, &#x27;y&#x27;: 34, &#x27;width&#x27;: 55.0, &#x27;height&#x27;: 55.0&#125;</span><br>    <span class="hljs-comment">#将鼠标悬停/一定到指定标签位置</span><br>    <span class="hljs-keyword">await</span> page.hover(<span class="hljs-string">&quot;div.JDJRV-slide-btn&quot;</span>)<br>    <span class="hljs-comment">#按下鼠标</span><br>    <span class="hljs-keyword">await</span> page.mouse.down()<br>    <span class="hljs-comment">#模拟人的行为进行滑动</span><br>    <span class="hljs-comment"># steps 是指分成几步来完成，steps越大，滑动速度越慢</span><br>    <span class="hljs-comment">#move(x,y)表示将鼠标移动到xy坐标位置</span><br>    <span class="hljs-comment">#random.uniform生成指定范围的随机浮点数</span><br>    <span class="hljs-keyword">await</span> page.mouse.move(box[<span class="hljs-string">&quot;x&quot;</span>] + distance + random.uniform(<span class="hljs-number">20</span>, <span class="hljs-number">40</span>),<br>                          box[<span class="hljs-string">&quot;y&quot;</span>],<br>                          &#123;<span class="hljs-string">&quot;steps&quot;</span>: <span class="hljs-number">100</span>&#125;)<br>    <span class="hljs-keyword">await</span> page.waitFor(<span class="hljs-number">1000</span>)<br><br>    <span class="hljs-keyword">await</span> page.mouse.up()<br>    <span class="hljs-keyword">await</span> page.waitFor(<span class="hljs-number">2000</span>)<br><br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(main())<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pyppeteer安装问题导致浏览器对象无法正常工作</title>
    <link href="/2023/12/19/pyppeteer%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/"/>
    <url>/2023/12/19/pyppeteer%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>pip install pyppeteer后自动下载chromium，但是似乎出了什么问题，当时ctrl c掉了，后续启动程序一直卡住</p><p>bro &#x3D; await launch(headless&#x3D;False)</p><p>调整成False观察浏览器情况，浏览器无法正常工作，手动键入 url也没用，怀疑是浏览器没装好</p><p>解决方案：</p><p>新建一个py文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> pyppeteer<br><br><span class="hljs-keyword">print</span>(pyppeteer.__chromium_revision__)  # 查看版本号<br><span class="hljs-keyword">print</span>(pyppeteer.executablePath())  # Chromium应该在的路径<br># <span class="hljs-number">588429</span><br># <span class="hljs-regexp">/home/</span>root<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/pyppeteer/</span>local-chromium<span class="hljs-regexp">/588429/</span>chrome-linux/chrome<br><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">588429</span><br><span class="hljs-regexp">/home/</span>kali<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/pyppeteer/</span>local-chromium<span class="hljs-regexp">/588429/</span>chrome-linux/chrome<br></code></pre></td></tr></table></figure><p>直接手动下载<a href="https://download-chromium.appspot.com/?platform=Linux_x64&type=snapshots">https://download-chromium.appspot.com/?platform=Linux_x64&amp;type=snapshots</a></p><p>到&#x2F;588429</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">unzip</span> chromium.zip<br></code></pre></td></tr></table></figure><p>重新检测</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><span class="hljs-comment">#创建一个特殊的函数</span><br><span class="hljs-keyword">async</span> def main():<br>    <span class="hljs-comment">#对应的pyppeteer相关的操作要写在特殊函数内部</span><br>    <span class="hljs-comment">#1.创建一个浏览器对象</span><br>    bro = <span class="hljs-keyword">await</span> launch(headless=False)<br>    <span class="hljs-comment">#2.创建一个新的page</span><br>    page = <span class="hljs-keyword">await</span> bro.newPage()<br>    <span class="hljs-comment">#3.发起请求</span><br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com/&#x27;</span>)<br>    <span class="hljs-comment">#4.获取页面源码数据</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">await</span> bro.close()<br><span class="hljs-comment">#创建一个协程对象</span><br>c = main()<br><span class="hljs-comment">#创建且启动事件循环对象</span><br><span class="hljs-keyword">loop</span> = asyncio.get_event_loop()<br><span class="hljs-keyword">loop</span>.run_until_complete(c)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进程、线程、协程</title>
    <link href="/2023/12/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
    <url>/2023/12/07/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程示例"><a href="#进程示例" class="headerlink" title="进程示例"></a>进程示例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_request</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在请求网址的数据：&#x27;</span>, url)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请求结束:&#x27;</span>, url)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    start = time.time()<br>    urls = [<span class="hljs-string">&#x27;www.1.com&#x27;</span>, <span class="hljs-string">&#x27;www.2.com&#x27;</span>, <span class="hljs-string">&#x27;www.3.com&#x27;</span>]<br>    p_list = []  <span class="hljs-comment"># 存储创建好的子进程</span><br>    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>        <span class="hljs-comment"># 创建子进程</span><br>        p = Process(target=get_request, args=(url,))<br>        p_list.append(p)<br>        <span class="hljs-comment"># p.join() #一定不要这么写</span><br>        <span class="hljs-comment"># 启动子进程</span><br>        p.start()<br><br>    <span class="hljs-keyword">for</span> pp <span class="hljs-keyword">in</span> p_list:  <span class="hljs-comment"># pp就是列表中的每一个子进程</span><br>        pp.join()  <span class="hljs-comment"># 是的每一个子进程都执行了join操作</span><br>        <span class="hljs-comment"># 意味着：主进程需要等待所有执行了join操作的子进程结束后再结束</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;总耗时：&#x27;</span>, time.time() - start)<br><br><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">正在请求网址的数据： www.<span class="hljs-number">1</span><span class="hljs-selector-class">.com</span><br>正在请求网址的数据： www.<span class="hljs-number">2</span><span class="hljs-selector-class">.com</span><br>正在请求网址的数据： www.<span class="hljs-number">3</span><span class="hljs-selector-class">.com</span><br>请求结束: www.<span class="hljs-number">1</span><span class="hljs-selector-class">.com</span><br>请求结束: www.<span class="hljs-number">2</span><span class="hljs-selector-class">.com</span><br>请求结束: www.<span class="hljs-number">3</span><span class="hljs-selector-class">.com</span><br>总耗时： <span class="hljs-number">2.026388645172119</span><br></code></pre></td></tr></table></figure><h1 id="线程示例"><a href="#线程示例" class="headerlink" title="线程示例"></a>线程示例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing.dummy <span class="hljs-keyword">import</span> Pool <span class="hljs-comment">#导入了线程池模块</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br>start = time.time()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_requests</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在爬取数据&#x27;</span>)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数据爬取结束&#x27;</span>)<br><br>urls = [<span class="hljs-string">&#x27;www.1.com&#x27;</span>,<span class="hljs-string">&#x27;www.2.com&#x27;</span>,<span class="hljs-string">&#x27;www.3.com&#x27;</span>,<span class="hljs-string">&#x27;www.4.com&#x27;</span>,<span class="hljs-string">&#x27;www.5.com&#x27;</span>]<br>ts = []<br><span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>    t = Thread(target=get_requests,args=(url,))<br>    t.start()<br>    ts.append(t)<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> ts:<br>    t.join()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;总耗时:&#x27;</span>,time.time()-start)<br><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">正在爬取数据<br>正在爬取数据<br>正在爬取数据<br>正在爬取数据<br>正在爬取数据<br>数据爬取结束<br>数据爬取结束<br>数据爬取结束<br>数据爬取结束<br>数据爬取结束<br><span class="hljs-section">总耗时: 2.0125858783721924</span><br></code></pre></td></tr></table></figure><p> 线程池</p><p>线程预先被创建并放入线程池中，同时处理完当前任务之后并不销毁而是被安排处理下一个任务，因此能够避免多次创建线程，从而节省线程创建和销毁的开销，能带来更好的性能和系统稳定性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing.dummy <span class="hljs-keyword">import</span> Pool <span class="hljs-comment">#导入了线程池模块</span><br><span class="hljs-keyword">import</span> time<br>urls = [<span class="hljs-string">&#x27;www.1.com&#x27;</span>,<span class="hljs-string">&#x27;www.2.com&#x27;</span>,<span class="hljs-string">&#x27;www.3.com&#x27;</span>,<span class="hljs-string">&#x27;www.4.com&#x27;</span>,<span class="hljs-string">&#x27;www.5.com&#x27;</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_reqeust</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在请求数据：&#x27;</span>,url)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请求结束:&#x27;</span>,url)<br>start = time.time()<br><span class="hljs-comment">#创建一个线程池,开启了5个线程</span><br>pool = Pool(<span class="hljs-number">5</span>)<br><span class="hljs-comment">#可以利用线程池中三个线程不断的去处理5个任务</span><br>pool.<span class="hljs-built_in">map</span>(get_reqeust,urls)<br><span class="hljs-comment">#get_reqeust函数调用的次数取决urls列表元素的个数</span><br><span class="hljs-comment">#get_requests每次执行都会接收urls列表中的一个元素作为参数</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;总耗时：&#x27;</span>,time.time()-start)<br>pool.close() <span class="hljs-comment">#释放线程池</span><br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">正在请求数据：正在请求数据： www.<span class="hljs-number">2</span><span class="hljs-selector-class">.com</span><br> www.<span class="hljs-number">1</span><span class="hljs-selector-class">.com</span><br>请求结束: 请求结束: www.<span class="hljs-number">1</span><span class="hljs-selector-class">.com</span><br>www.<span class="hljs-number">2</span><span class="hljs-selector-class">.com</span><br>正在请求数据： www.<span class="hljs-number">3</span><span class="hljs-selector-class">.com</span><br>正在请求数据： www.<span class="hljs-number">4</span><span class="hljs-selector-class">.com</span><br>请求结束: www.<span class="hljs-number">4</span><span class="hljs-selector-class">.com</span><br>正在请求数据： www.<span class="hljs-number">5</span><span class="hljs-selector-class">.com</span><br>请求结束: www.<span class="hljs-number">3</span><span class="hljs-selector-class">.com</span><br>请求结束: www.<span class="hljs-number">5</span><span class="hljs-selector-class">.com</span><br>总耗时： <span class="hljs-number">6.045103311538696</span><br><br></code></pre></td></tr></table></figure><h1 id="协程示例"><a href="#协程示例" class="headerlink" title="协程示例"></a>协程示例</h1><h2 id="回调函数用法"><a href="#回调函数用法" class="headerlink" title="回调函数用法"></a>回调函数用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 特殊的函数：</span><br><span class="hljs-comment">#     在函数定义前添加一个async关键字，该函数就变成了一个特殊的函数。</span><br><span class="hljs-comment">#     特殊函数的特殊之处：</span><br><span class="hljs-comment">#         1. 特殊函数被调用后，函数内部的程序语句不会被立即执行.</span><br><span class="hljs-comment">#         2. 特殊函数被调用后，会返回一个协程对象</span><br><span class="hljs-comment"># 协程：</span><br><span class="hljs-comment">#     特殊函数调用后，返回一个协程对象（协程对象是由特殊函数创建）</span><br><span class="hljs-comment">#     协程 == 特殊的函数 == 函数 == 一组指定形式的操作</span><br><span class="hljs-comment">#     协程 == 一组指定形式的操作</span><br><span class="hljs-comment"># 任务对象：</span><br><span class="hljs-comment">#     任务对象本质上是一个高级的协程。高级之处是什么？后面讲！</span><br><span class="hljs-comment">#     任务对象 == 高级协程 == 协程 == 一组指定形式的操作</span><br><span class="hljs-comment">#     任务对象 == 一组指定形式的操作</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 事件循环loop：</span><br><span class="hljs-comment">#     当做是一种容器。该容器是用来装载多个任务对象。</span><br><span class="hljs-comment">#     loop就可以将其内部装载的任务对象进行异步的执行。</span><br><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_request</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在请求的网址是:&#x27;</span>,url)<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请求网址结束！&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span><br><br><span class="hljs-comment">#如何获取特殊函数内部的返回值（任务对象回调函数来实现的）</span><br>c = get_request(<span class="hljs-string">&#x27;www.1.com&#x27;</span>)<br>task = asyncio.ensure_future(c)<br><span class="hljs-comment">#给任务对象绑定一个回调函数（回头调用的函数）,该函数一定是在任务对象被执行完毕后再调用的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">task_callback</span>(<span class="hljs-params">t</span>): <span class="hljs-comment">#必须有且仅有一个参数</span><br>    <span class="hljs-comment">#函数的参数t就是回调函数的调用者task任务对象本身</span><br>    ret = t.result() <span class="hljs-comment">#任务对象调用result()就可以返回特殊函数的内部return后的结果值</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是回调函数，我被执行了，t.result()返回的结果是:&#x27;</span>,ret)<br><span class="hljs-comment">#给task任务对象绑定了一个叫做task_callback的回调函数</span><br>task.add_done_callback(task_callback)<br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(task)<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">正在请求的网址是: www.1.com</span><br>请求网址结束！<br><span class="hljs-section">我是回调函数，我被执行了，t.result()返回的结果是: 123</span><br></code></pre></td></tr></table></figure><h2 id="多任务示例"><a href="#多任务示例" class="headerlink" title="多任务示例"></a>多任务示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 特殊的函数：</span><br><span class="hljs-comment">#     在函数定义前添加一个async关键字，该函数就变成了一个特殊的函数。</span><br><span class="hljs-comment">#     特殊函数的特殊之处：</span><br><span class="hljs-comment">#         1. 特殊函数被调用后，函数内部的程序语句不会被立即执行.</span><br><span class="hljs-comment">#         2. 特殊函数被调用后，会返回一个协程对象</span><br><span class="hljs-comment"># 协程：</span><br><span class="hljs-comment">#     特殊函数调用后，返回一个协程对象（协程对象是由特殊函数创建）</span><br><span class="hljs-comment">#     协程 == 特殊的函数 == 函数 == 一组指定形式的操作</span><br><span class="hljs-comment">#     协程 == 一组指定形式的操作</span><br><span class="hljs-comment"># 任务对象：</span><br><span class="hljs-comment">#     任务对象本质上是一个高级的协程。高级之处是什么？后面讲！</span><br><span class="hljs-comment">#     任务对象 == 高级协程 == 协程 == 一组指定形式的操作</span><br><span class="hljs-comment">#     任务对象 == 一组指定形式的操作</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 事件循环loop：</span><br><span class="hljs-comment">#     当做是一种容器。该容器是用来装载多个任务对象。</span><br><span class="hljs-comment">#     loop就可以将其内部装载的任务对象进行异步的执行。</span><br><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br>start = time.time()<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_request</span>(<span class="hljs-params">url</span>):<br>    <span class="hljs-comment">#特殊函数内部不可以出现不支持异步模块的代码，否则会中断整个异步效果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在请求的网址是:&#x27;</span>,url)<br>    <span class="hljs-comment">#没有加await关键字之前：每一个任务中的阻塞操作并没有被执行</span><br>    <span class="hljs-comment">#await关键字：必须要加在每一个任务的阻塞操作前，作用就是强调执行任务中的阻塞操作</span><br>    <span class="hljs-comment">#await是用来手动控制任务的挂起操作。</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请求网址结束！&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span><br><br>urls = [<br>    <span class="hljs-string">&#x27;www.1.com&#x27;</span>,<span class="hljs-string">&#x27;www.2.com&#x27;</span>,<span class="hljs-string">&#x27;www.3.com&#x27;</span><br>]<br><br>tasks = [] <span class="hljs-comment">#定义一个任务列表</span><br><span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls: <span class="hljs-comment">#循环3次</span><br>    <span class="hljs-comment">#创建了3个协程</span><br>    c = get_request(url)<br>    <span class="hljs-comment">#创建3个任务对象</span><br>    task = asyncio.ensure_future(c)<br>    tasks.append(task) <span class="hljs-comment">#将创建好的3个任务对象依次存放到了tasks这个任务列表中</span><br><br>loop = asyncio.get_event_loop()<br><span class="hljs-comment">#将任务列表tasks添加到loop容器中</span><br><span class="hljs-comment">#wait()函数：用于接收一个任务列表，wait函数就可以给任务列表中每一个任务对象赋予一个可被挂起的权限</span><br><span class="hljs-comment">#一个任务被挂起，就表示当前任务对象交出了cpu的使用权</span><br>loop.run_until_complete(asyncio.wait(tasks))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;总耗时:&#x27;</span>,time.time()-start)<br></code></pre></td></tr></table></figure><p>执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">正在请求的网址是: www.1.com</span><br><span class="hljs-section">正在请求的网址是: www.2.com</span><br><span class="hljs-section">正在请求的网址是: www.3.com</span><br>请求网址结束！<br>请求网址结束！<br>请求网址结束！<br><span class="hljs-section">总耗时: 2.006136417388916</span><br></code></pre></td></tr></table></figure><h2 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python3">import asyncio<br>import time<br>import aiohttp<br># import requests<br><br>from lxml import etree<br>start = time.time()<br><br>urls = [<br>    &#x27;http://127.0.0.1:5000/bobo&#x27;,<br>    &#x27;http://127.0.0.1:5000/jay&#x27;,<br>    &#x27;http://127.0.0.1:5000/tom&#x27;<br>]<br><br>#发起网络请求，爬取网页完整数据<br>async def get_request(url):<br>    #不可以出现不支持异步模块的代码<br>    #requests是不支持异步，更换一个支持异步的网络请求的模块（aiohttp）<br>    # response = requests.get(url=url)<br>    # page_text = response.text<br>    # return page_text<br><br>    #aiohttp进行网络请求的代码操作<br>    #1.创建一个请求对象:sess<br>    async with aiohttp.ClientSession() as sess:<br>        #2.使用请求对象发起请求<br>        #aiohttp发起请求的代码操作和requests几乎一致，唯一不一致的地方是，使用代理的参数proxy=&quot;http://ip:port&quot;<br>        async with await sess.get(url=url) as response:<br>            #text()获取字符串形式的响应数据<br>            #read()获取二进制形式的响应数据<br>            #json()和以前的作用一致<br>            page_text = await response.text()<br>            return page_text<br>tasks = []<br>def parse(t): #数据解析<br>    page_text = t.result()<br>    tree = etree.HTML(page_text)<br>    text = tree.xpath(&#x27;//a[@id=&quot;feng&quot;]/text()&#x27;)[0]<br>    print(text)<br>for url in urls:<br>    c = get_request(url)<br>    task = asyncio.ensure_future(c)<br>    #给任务对象绑定回调函数用于数据解析<br>    task.add_done_callback(parse)<br>    tasks.append(task)<br><br>loop = asyncio.get_event_loop()<br>loop.run_until_complete(asyncio.wait(tasks))<br><br>print(&#x27;总耗时:&#x27;,time.time()-start)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git使用</title>
    <link href="/2023/10/10/git%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/10/10/git%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>hexo简单使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建hexo new <span class="hljs-string">&quot;f&quot;</span><span class="hljs-regexp">//</span>清理hexo clean<span class="hljs-regexp">//</span>构建静态文件hexo g<span class="hljs-regexp">//</span>上传至仓库hexo d<br></code></pre></td></tr></table></figure><h1 id="1-git基本使用"><a href="#1-git基本使用" class="headerlink" title="1 git基本使用"></a>1 git基本使用</h1><ul><li><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2></li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span><br></code></pre></td></tr></table></figure><p>两种颜色，红色代表工作区的文件，绿色代表缓存区</p><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20231010163623191.png" alt="image-20231010163623191"></p><ul><li><h2 id="添加到缓存区"><a href="#添加到缓存区" class="headerlink" title="添加到缓存区"></a>添加到缓存区</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">add</span> <span class="hljs-string">&#x27;&#x27;</span><br>git <span class="hljs-keyword">add</span> .<br>git <span class="hljs-keyword">add</span> -A <span class="hljs-comment">//使用-A参数表示暂存所有已修改文件：</span><br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20231010164020349.png" alt="image-20231010164020349"></p></li><li><h2 id="查看未暂存和已暂存的修改"><a href="#查看未暂存和已暂存的修改" class="headerlink" title="查看未暂存和已暂存的修改"></a>查看未暂存和已暂存的修改</h2><p>在工作区工作的时候，我们想要知道：</p><ul><li>当前做的哪些更新没有暂存？</li><li>有哪些更新已经暂存起来准备下次提交？</li></ul><p>使用<code>git status</code>命令只能表明文件，要查看具体内容使用该命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git diff</span><br></code></pre></td></tr></table></figure><p>该命令比较工作目录中和暂存区文件的差异，即：<strong>已经修改但还未暂存的内容</strong>，<strong>最后通过文件补丁的格式表明具体哪些行发生了变化</strong>。</p></li></ul><p>​在2.txt中添加文本，然后分别使用<code>git status</code>和<code>git diff</code>查看</p><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20240105105644820.png" alt="image-20240105105644820"></p><p>如果需要查看已经暂存起来的修改使用如下命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git diff <span class="hljs-comment">--staged</span><br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20240105105915088.png" alt="image-20240105105915088"></p><ul><li><h2 id="提交更新到仓库"><a href="#提交更新到仓库" class="headerlink" title="提交更新到仓库"></a>提交更新到仓库</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&#x27;备注(version)&#x27;</span><br></code></pre></td></tr></table></figure></li><li><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/640.png" alt="图片"></p></li><li><h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2></li></ul><p>要从Git的暂存区和仓库中移除一个文件，有两种情况：</p><ul><li>从暂存区删除，并且从工作目录删除源文件：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git rm <span class="hljs-tag">&lt;<span class="hljs-name">文件名</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>从暂存区删除，保留工作区的源文件：</li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git rm <span class="hljs-comment">--cached &lt;文件名&gt;</span><br></code></pre></td></tr></table></figure><ul><li><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard ID</span><br></code></pre></td></tr></table></figure></li><li><h2 id="变动文件返回原始状态"><a href="#变动文件返回原始状态" class="headerlink" title="变动文件返回原始状态"></a>变动文件返回原始状态</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- 文件名</span><br></code></pre></td></tr></table></figure></li><li><h2 id="缓存区转换为工作区"><a href="#缓存区转换为工作区" class="headerlink" title="缓存区转换为工作区"></a>缓存区转换为工作区</h2><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">reset</span> HEAD 文件名<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20231010164626881.png" alt="image-20231010164626881"></p><h1 id="2-git进阶"><a href="#2-git进阶" class="headerlink" title="2 git进阶"></a>2 git进阶</h1><h2 id="2-1-枝干概念"><a href="#2-1-枝干概念" class="headerlink" title="2.1 枝干概念"></a>2.1 枝干概念</h2><ul><li><p>查看枝干</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure></li><li><p>创建</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch debug_dev</span><br></code></pre></td></tr></table></figure></li><li><p>切换</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git checkout debug_dev</span><br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20231010165227912.png" alt="image-20231010165227912"></p></li></ul><h2 id="2-2切换分支后的操作"><a href="#2-2切换分支后的操作" class="headerlink" title="2.2切换分支后的操作"></a>2.2切换分支后的操作</h2><h3 id="2-2-1合并分支"><a href="#2-2-1合并分支" class="headerlink" title="2.2.1合并分支"></a>2.2.1合并分支</h3><p>要将一个分支所做的更新合并，需要进行两个操作：</p><ol><li><p>切换到要合并的分支上；</p><p>创建文件提交至缓存</p><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20240105114047417.png" alt="image-20240105114047417"></p></li><li><p>执行命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git checkout main <span class="hljs-regexp">//</span>切换到主分支<br>git merge &lt;待合并的分支名称&gt;  <span class="hljs-regexp">//</span>合并dev_1  的内容<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20240105114318449.png" alt="image-20240105114318449"></p></li></ol><h3 id="2-2-2解决合并产生的冲突"><a href="#2-2-2解决合并产生的冲突" class="headerlink" title="2.2.2解决合并产生的冲突"></a>2.2.2解决合并产生的冲突</h3><p>当我们在不同的分支上修改了同一文件的同一个地方的内容，在两者同时合并到主分支上时会产生冲突，合并时会提示<strong>自动合并失败，进入手动合并模式</strong>，如图：</p><p><img src="C:\Users\wycywlt\AppData\Roaming\Typora\typora-user-images\image-20240105115023860.png" alt="image-20240105115023860"></p><ol><li><p>手动修改文件，并删除Git添加的多余符号：</p><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20240105115355538.png" alt="image-20240105115355538"></p></li><li><p>手动修改文件到满意的程度；</p></li><li><p>添加修改到暂存区<code>git add &lt;文件名&gt;</code>；</p></li><li><p>提交更新<code>git commit -m &lt;提交信息&gt;</code></p></li></ol><h2 id="2-3-远程仓库推拉操作"><a href="#2-3-远程仓库推拉操作" class="headerlink" title="2.3 远程仓库推拉操作"></a>2.3 远程仓库推拉操作</h2><h3 id="2-3-1-创建本地库"><a href="#2-3-1-创建本地库" class="headerlink" title="2.3.1 创建本地库"></a>2.3.1 创建本地库</h3><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20240105115625919.png" alt="image-20240105115625919"></p><h3 id="2-3-2-创建远程仓库"><a href="#2-3-2-创建远程仓库" class="headerlink" title="2.3.2 创建远程仓库"></a>2.3.2 创建远程仓库</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote add &lt;别名&gt; &lt;远程库地址&gt;<br>git remote -v //查看别名和远程仓库地址的映射关系<br></code></pre></td></tr></table></figure><h3 id="2-3-3-拉取操作"><a href="#2-3-3-拉取操作" class="headerlink" title="2.3.3 拉取操作"></a>2.3.3 拉取操作</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git pull &lt;远程库地址名&gt; &lt;远程分支名称&gt;<br></code></pre></td></tr></table></figure><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20240105142731370.png" alt="image-20240105142731370"></p><p>2.3.4 推送操作</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git push &lt;远程库地址/别名&gt; &lt;要推送信息的分支(本地)&gt;<br></code></pre></td></tr></table></figure><p>在本地创建一个文件然后提交更新 </p><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20240105143029147.png" alt="image-20240105143029147"></p><h3 id="2-3-4克隆操作"><a href="#2-3-4克隆操作" class="headerlink" title="2.3.4克隆操作"></a>2.3.4克隆操作</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git clone &lt;远程库url&gt;<br></code></pre></td></tr></table></figure><p>这样克隆的效果有（<strong>重点</strong>）：</p><ul><li>将远程仓库的所有内容克隆到本地（避免了拉取操作）；</li><li>默认创建了origin作为远程仓库地址的别名（避免了取别名的操作）；</li><li>初始化了本地库（避免了初始化操作）；</li></ul><p><strong>克隆成功后可以直接进行拉取和推送操作</strong></p><h1 id="3-github的一些问题"><a href="#3-github的一些问题" class="headerlink" title="3 github的一些问题"></a>3 github的一些问题</h1><p><strong>使用个人访问令牌 (Personal Access Token)</strong>: 您可以生成一个个人访问令牌，然后将其用作密码来进行身份验证。访问令牌是一种安全的方式，用于代替密码，以便您可以继续使用 HTTPS 进行操作。</p><ul><li><p>在 GitHub 上生成个人访问令牌：您可以登录到 GitHub 帐户，然后转到 “Settings”（设置）&gt; “Developer settings”（开发者设置）&gt; “Personal access tokens”（个人访问令牌）来生成一个新的访问令牌。请确保为令牌授予适当的权限（例如，repo、read:user、user:email 等）。</p></li><li><p>在命令行中使用个人访问令牌：将生成的个人访问令牌用作密码来执行 <code>git push</code> 命令。示例命令如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">bashCopy codegit <span class="hljs-keyword">push</span> -u origin master<br><span class="hljs-symbol">Username:</span> your_username<br><span class="hljs-symbol">Password:</span> your_personal_access_token<br></code></pre></td></tr></table></figure></li></ul><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20231010165447548.png" alt="image-20231010165447548"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Segment routingMPLS</title>
    <link href="/2023/09/12/Segment%20routing%20MPLS/"/>
    <url>/2023/09/12/Segment%20routing%20MPLS/</url>
    
    <content type="html"><![CDATA[<h2 id="Segment-Routing-MPLS基本原理"><a href="#Segment-Routing-MPLS基本原理" class="headerlink" title="Segment Routing MPLS基本原理"></a>Segment Routing MPLS基本原理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Segment Routing MPLS特性涉及的概念如下：</p><ul><li>SR域（Segment Routing Domain）：SR节点的集合。</li><li>SID：即Segment ID，用来标识唯一的段。在转发层面，可以映射为MPLS标签。</li><li>SRGB（Segment Routing Global Block）：用户指定的为Segment Routing MPLS预留的全局标签集合。</li><li>SRLB（Segment Routing Local Block）：用户指定的为Segment Routing MPLS预留的本地标签集合。这些标签在本地配置，仅在本地有效，但是会通过IGP对外发布，所以是全局可见。SRLB当前主要用于配置<a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000173014/3ee10304#ZH-CN_CONCEPT_0172355658">Binding SID</a>。</li></ul><h3 id="Segment分类"><a href="#Segment分类" class="headerlink" title="Segment分类"></a>Segment分类</h3><p><strong>表1-1</strong> Segment分类</p><table><thead><tr><th>标签</th><th>生成方式</th><th>作用</th></tr></thead><tbody><tr><td>Prefix Segment（前缀段）</td><td>手工配置。</td><td>Prefix Segment用于标识网络中的某个目的地址前缀（Prefix）。Prefix Segment通过IGP协议扩散到其他网元，全局可见，全局有效。Prefix Segment通过Prefix Segment ID（SID）标识。Prefix SID是源端发布的SRGB范围内的偏移值，接收端会根据自己的SRGB计算实际标签值用于生成MPLS转发表项。</td></tr><tr><td>Adjacency Segment（邻接段）</td><td>源节点通过协议动态分配。也可以手工配置。</td><td>Adjacency Segment用于标识网络中的某个邻接。Adjacency Segment通过IGP协议扩散到其他网元，全局可见，本地有效。Adjacency Segment通过Adjacency Segment ID（SID）标识。Adjacency SID为SRGB范围外的本地SID。</td></tr><tr><td>Node Segment（节点段）</td><td>手工配置。</td><td>Node Segment是特殊的Prefix Segment，用于标识特定的节点（Node）。在节点的Loopback接口下配置IP地址作为前缀，这个节点的Prefix SID实际就是Node SID。</td></tr></tbody></table><p>Prefix SID、Adjacency SID和Node SID的示例如<a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000173014/3ee10304#ZH-CN_CONCEPT_0161511638_mMcCpPsS_fig2">图1-2</a>所示。</p><p><strong>图1-2</strong> Prefix SID、Adjacency SID和Node SID<br><img src="https://download.huawei.com/mdl/image/download?uuid=44248c67db3f44c2a4471ebeef0dbfa8" alt="img"></p><p>通俗的理解，Prefix SID代表目的地址，Adjacency SID代表数据包的外发链路，可以分别类似于传统IP转发中的目的IP地址和出接口。在IGP区域内，网元设备使用扩展IGP消息将自身的Node SID以及Adjacency SID进行泛洪，这样任意一个网元都可以获得其他网元的信息。</p><p>通过按序组合前缀（节点）SID和邻接SID，可以构建出网络内的任何路径。在路径中的每一跳，使用栈顶段信息区分下一跳。段信息按照顺序堆叠在数据头的顶部。当栈顶段信息包含另一个节点的标识时，接收节点使用等价多路径（ECMP）将数据包转发到下一跳。当栈顶段信息是本节点的标识时，接收节点弹出顶部段并执行下一个段所需的任务。</p><p><strong>Prefix SID</strong></p><p>基于Prefix SID的转发路径是由IGP通过最短路径算法（SPF）计算得出。如<a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000173014/3ee10304#fig_dc_vrp_sr_all_feature_000802">图1-3</a>所示，以节点Z为目的节点，其Prefix SID是100，通过IGP扩散之后，整个IGP域的所有设备学习到节点Z的Prefix SID，之后都会使用SPF算法得出一条到节点Z的最短路径（Shortest Path），也即开销最小路径。</p><p><strong>图1-3</strong> 基于Prefix SID的转发路径<br><img src="https://download.huawei.com/mdl/image/download?uuid=69ee5dab8b334659b9256f903e89765d" alt="img"></p><p>如果网络中存在等价路径，则可以实现负载分担（ECMP）；如果存在不等价路径，则可以形成链路备份。由此可见，基于Prefix SID的转发路径并不是一条固定路径，头节点也无法控制报文的整条转发路径。</p><p><strong>Adjacency SID</strong></p><p>如<a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000173014/3ee10304#fig_dc_vrp_sr_all_feature_000803">图1-4</a>所示，通过给网络中每个邻接分配一个Adjacency SID，然后在头节点定义一个包含多个Adjacency SID的Segment List，就可以严格指定任意一条显式路径（Strict Explicit）。这种方式可以更好的配合实现SDN。</p><p><strong>图1-4</strong> 基于Adjacency SID的转发路径<br><img src="https://download.huawei.com/mdl/image/download?uuid=7beb5db96a3b45b796ddb8535651372a" alt="img"></p><p><strong>Adjacency SID + Node SID</strong></p><p>如<a href="https://support.huawei.com/enterprise/zh/doc/EDOC1000173014/3ee10304#fig_dc_vrp_sr_all_feature_000804">图1-5</a>所示，这种方式是将Adjacency SID和Node SID结合，通过Adjacency SID，可以强制整条路径包含某一个邻接。而对于Node SID，节点可以使用SPF算法计算最短路径，也可以负载分担。这种方式的路径并不是严格固定，所以也称作松散路径（Loose Explicit）。</p><p><strong>图1-5</strong> 基于Adjacency SID + Node SID的转发路径<br><img src="https://download.huawei.com/mdl/image/download?uuid=09355c492a384fc5b9935ccc780c385b" alt="img"></p><h3 id="Segment-Routing转发机制"><a href="#Segment-Routing转发机制" class="headerlink" title="Segment Routing转发机制"></a>Segment Routing转发机制</h3><p>Segment Routing可以直接应用在MPLS架构，转发机制没有变化。代表段的SID被编码为MPLS标签。段序列被编码为标签栈。要处理的段位于栈顶。一个段处理完成后，相关标签从标签栈中弹出。</p><p>基于MPLS转发机制的SR，通常也称为SR-MPLS。</p><h3 id="Segment-Routing标签冲突处理原则"><a href="#Segment-Routing标签冲突处理原则" class="headerlink" title="Segment Routing标签冲突处理原则"></a>Segment Routing标签冲突处理原则</h3><p>由于Prefix SID通过手工配置生成，不同设备上的配置可能发生标签冲突。标签冲突分为前缀冲突和SID冲突，前缀冲突是指相同的前缀关联了两个不同的SID，SID冲突是指相同的SID关联到不同的前缀。</p><p>标签冲突处理原则：当冲突产生后，优先处理前缀冲突，之后根据处理结果再进行SID冲突处理，并按如下规则进行优选。</p><ol><li>前缀掩码更大者优选；</li><li>前缀更小者优选；</li><li>SID更小者优选。</li></ol><p>假如现在有如下四条路由(前缀&#x2F;掩码 SID)：</p><ul><li>a. 1.1.1.1&#x2F;32 1</li><li>b. 1.1.1.1&#x2F;32 2</li><li>c. 2.2.2.2&#x2F;32 3</li><li>d. 3.3.3.3&#x2F;32 1</li></ul><p>使用冲突处理原则后效果如下：</p><ol><li>先进行前缀冲突处理，a和b为前缀冲突，根据标签冲突处理原则，a的SID比b的SID小，优选a，则处理后：<ul><li>a. 1.1.1.1&#x2F;32 1</li><li>c. 2.2.2.2&#x2F;32 3</li><li>d. 3.3.3.3&#x2F;32 1</li></ul></li><li>再根据上一步处理结果进行SID冲突处理，a和d为SID冲突，根据标签冲突处理原则，a的前缀比d的前缀小，优选a。冲突解决后，最终优选出两条路由：<ul><li>a. 1.1.1.1&#x2F;32 1</li><li>c. 2.2.2.2&#x2F;32 3</li></ul></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的TCP代理</title>
    <link href="/2023/08/11/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84TCP%E4%BB%A3%E7%90%86/"/>
    <url>/2023/08/11/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84TCP%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>以下是一个简单的 TCP 代理服务器的代码示例。这个代理服务器会监听指定的端口，接受客户端连接，并将客户端的数据转发到远程服务器，然后将远程服务器的响应返回给客户端。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proxy_handler</span>(<span class="hljs-params">client_socket, remote_host, remote_port</span>):<br>    remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    remote_socket.connect((remote_host, remote_port))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward_data</span>(<span class="hljs-params">source, destination</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data = source.recv(<span class="hljs-number">4096</span>)  <span class="hljs-comment"># 从源套接字接收数据</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                <span class="hljs-keyword">break</span><br>            destination.send(data)  <span class="hljs-comment"># 将接收到的数据发送到目标套接字</span><br><br>    <span class="hljs-comment"># 创建两个线程用于数据转发</span><br>    client_thread = threading.Thread(target=forward_data, args=(client_socket, remote_socket))<br>    remote_thread = threading.Thread(target=forward_data, args=(remote_socket, client_socket))<br><br>    <span class="hljs-comment"># 启动线程</span><br>    client_thread.start()<br>    remote_thread.start()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    local_host = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>  <span class="hljs-comment"># 本地监听的 IP 地址</span><br>    local_port = <span class="hljs-number">6666</span>  <span class="hljs-comment"># 本地监听的端口</span><br><br>    remote_host = <span class="hljs-string">&#x27;www.google.com&#x27;</span>  <span class="hljs-comment"># 远程服务器的主机名</span><br>    remote_port = <span class="hljs-number">80</span>  <span class="hljs-comment"># 远程服务器的端口号</span><br><br>    <span class="hljs-comment"># 创建服务器套接字并绑定到本地地址和端口</span><br>    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    server.bind((local_host, local_port))<br>    server.listen(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 监听连接，最大允许 5 个等待连接</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[*] Listening on <span class="hljs-subst">&#123;local_host&#125;</span>:<span class="hljs-subst">&#123;local_port&#125;</span>&#x27;</span>)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        client_socket, client_addr = server.accept()  <span class="hljs-comment"># 接受客户端连接</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;[*] Accepted connection from: <span class="hljs-subst">&#123;client_addr[<span class="hljs-number">0</span>]&#125;</span>:<span class="hljs-subst">&#123;client_addr[<span class="hljs-number">1</span>]&#125;</span>&#x27;</span>)<br><br>        <span class="hljs-comment"># 创建代理处理线程</span><br>        proxy_thread = threading.Thread(target=proxy_handler, args=(client_socket, remote_host, remote_port))<br>        proxy_thread.start()  <span class="hljs-comment"># 启动代理处理线程</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()  <span class="hljs-comment"># 启动主函数</span><br></code></pre></td></tr></table></figure><p>在这个示例中：</p><ol><li><code>proxy_handler(client_socket, remote_host, remote_port)</code> 函数用于处理代理连接，将数据从客户端传递给远程服务器，同时也从远程服务器传递数据回客户端。</li><li><code>forward_data(source, destination)</code> 函数用于将数据从源套接字传递到目标套接字，以实现数据转发。</li><li><code>main()</code> 函数用于创建服务器套接字，监听指定的本地 IP 和端口，然后循环接受客户端连接并启动代理线程。</li></ol><p>请注意，这个示例是一个简单的 TCP 代理，实际应用中可能需要更多的错误处理、安全性考虑以及对数据的处理和修改。在使用这个代码示例时，务必遵守适用法律和法规，并确保你有权限进行代理操作。</p><p>一个简单的tcp客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br>target_host = <span class="hljs-string">&quot;192.168.233.129&quot;</span><br>target_port = <span class="hljs-number">6666</span><br><br><span class="hljs-comment"># create a socket object</span><br>client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># connect the client</span><br>client.connect((target_host, target_port))<br><br><span class="hljs-comment"># send some data</span><br>client.send(<span class="hljs-string">b&quot;GET / HTTP/1.1\r\nHost: google.com\r\n\r\n&quot;</span>)<br><br>response = client.recv(<span class="hljs-number">4096</span>)<br><br><span class="hljs-built_in">print</span>(response.decode())<br>client.close()<br>~                     <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python黑帽子学习笔记(一)</title>
    <link href="/2023/08/03/python%E9%BB%91%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <url>/2023/08/03/python%E9%BB%91%E5%B8%BD%E5%AD%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="1-网络传输中的数据对象类型"><a href="#1-网络传输中的数据对象类型" class="headerlink" title="1 网络传输中的数据对象类型"></a>1 网络传输中的数据对象类型</h1><p>网络传输的数据是字节对象（<code>bytes</code>）的主要原因是因为计算机和网络是基于二进制的。</p><p>在计算机和网络中，数据的最小单位是比特（bit），即二进制的 0 和 1。所有的数据在传输和存储时，都需要被转换为比特流（bit stream）。由于字节（byte）是计算机中常用的基本存储单元，一个字节由 8 个比特组成，因此数据通常以字节为单位进行传输和存储。</p><p>字节对象（<code>bytes</code>）是 Python 中专门用于表示原始二进制数据的数据类型。它是一个不可变的序列，由 8 位二进制组成，表示一个字节的数据。</p><p>在网络通信中，数据需要通过网络传输到远程主机或从远程主机接收，而网络通信使用的底层协议（如 TCP 和 UDP）是基于字节流的。因此，数据在进行网络传输时，需要被转换为字节对象，以便在网络中传输。</p><p>使用字节对象的好处是：</p><ol><li><p><strong>二进制表示：</strong> 字节对象直接以二进制形式表示数据，没有编码的附加信息，使得数据的传输和解析更高效。</p></li><li><p><strong>兼容性：</strong> 字节对象可以表示各种类型的数据，包括文本、图像、音频、视频等，不受编码方式和字符集的限制。</p></li><li><p><strong>数据完整性：</strong> 在网络传输过程中，数据可能会经历多个网络设备和协议层的处理，使用字节对象可以确保数据在传输过程中的完整性。</p></li></ol><p>在 Python 中，当进行网络编程时，使用字节对象可以更好地处理和表示网络传输的数据，确保数据在不同平台和系统之间的正确传输和解析。同时，在 Python 3 中，字符串（<code>str</code>）和字节对象（<code>bytes</code>）是明确区分的，这使得数据的处理更加明确和可靠。</p><h1 id="2-开发一个TCP代理"><a href="#2-开发一个TCP代理" class="headerlink" title="2 开发一个TCP代理"></a>2 开发一个TCP代理</h1><p>4个主要功能：把本地设备和远程设备之间的通信过程显示到屏幕上（hexdump函数）；从本地设备或远程设备的入口socket接收数据（receive_from函数）；控制远程设备和本地设备之间的流量方向（proxy_handler函数）；最后，还需要创建一个监听socket，并把它传给我们的proxy_handler（server_loop函数）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码块1-hexdump函数"><a href="#代码块1-hexdump函数" class="headerlink" title="代码块1 hexdump函数"></a>代码块1 hexdump函数</h3><p>把本地设备和远程设备之间的通信过程显示到屏幕上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> threading<br><br><br>HEX_FILTER = <span class="hljs-string">&#x27;&#x27;</span>.join(<br>    [(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">repr</span>(<span class="hljs-built_in">chr</span>(i))) == <span class="hljs-number">3</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>)]<br>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hexdump</span>(<span class="hljs-params">src, length=<span class="hljs-number">16</span>, show=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(src, <span class="hljs-built_in">bytes</span>):<br>        src = src.decode()<br><br>    results = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(src), length):<br>        word = <span class="hljs-built_in">str</span>(src[i:i+length])<br>        printable = word.translate(HEX_FILTER)<br>        hexa = <span class="hljs-string">&#x27; &#x27;</span>.join([<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">ord</span>(c):02X&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word])<br>        hexwidth = length*<span class="hljs-number">3</span><br>        results.append(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i:04x&#125;</span> <span class="hljs-subst">&#123;hexa:&lt;&#123;hexwidth&#125;</span>&#125; <span class="hljs-subst">&#123;printable&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">if</span> show:<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> results:<br>            <span class="hljs-built_in">print</span>(line)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><p>这段代码定义了一个函数 <code>hexdump</code>，用于以十六进制和 ASCII 码的形式打印字节数据或字符串。</p><p>让我们来解释这个函数的作用和实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">HEX_FILTER = <span class="hljs-string">&#x27;&#x27;</span>.join([(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">repr</span>(<span class="hljs-built_in">chr</span>(i))) == <span class="hljs-number">3</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">256</span>)])<br></code></pre></td></tr></table></figure><ul><li><code>HEX_FILTER</code> 是一个字符串，用于过滤非打印字符，将它们用 ‘.’ 代替。该字符串包含了所有 ASCII 码值在 0 到 255 范围内的字符，通过 <code>repr()</code> 函数判断字符是否是可打印字符，不可打印字符用 ‘.’ 表示。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">hexdump</span>(<span class="hljs-params">src, length=<span class="hljs-number">16</span>, show=<span class="hljs-literal">True</span></span>):<br></code></pre></td></tr></table></figure><ul><li><code>hexdump</code> 函数接收三个参数：<ul><li><code>src</code>: 要打印的数据，可以是字节对象（<code>bytes</code>）或字符串（<code>str</code>）。</li><li><code>length</code>: 每行显示的数据长度，默认为 16 字节。</li><li><code>show</code>: 是否立即打印输出结果，默认为 True。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(src, <span class="hljs-built_in">bytes</span>):<br>    src = src.decode()<br></code></pre></td></tr></table></figure><ul><li>这段代码用于判断 <code>src</code> 是否是字节对象（<code>bytes</code>）。如果是字节对象，则将其转换为字符串，方便后续处理。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">results = <span class="hljs-built_in">list</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(src), length):<br>    word = <span class="hljs-built_in">str</span>(src[i:i+length])<br>    printable = word.translate(HEX_FILTER)<br>    hexa = <span class="hljs-string">&#x27; &#x27;</span>.join([<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">ord</span>(c):02X&#125;</span>&#x27;</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> word])<br>    hexwidth = length*<span class="hljs-number">3</span><br>    results.append(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;i:04x&#125;</span> <span class="hljs-subst">&#123;hexa:&lt;&#123;hexwidth&#125;</span>&#125; <span class="hljs-subst">&#123;printable&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>这部分代码是核心逻辑，将数据按每行 <code>length</code> 字节进行切片，并转换为十六进制字符串和 ASCII 可打印字符串。</li><li><code>word</code> 变量是当前行的数据片段，<code>hexa</code> 是该行数据的十六进制表示，<code>printable</code> 是该行数据的 ASCII 可打印表示。</li><li><code>results</code> 列表保存了每行的结果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> show:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> results:<br>        <span class="hljs-built_in">print</span>(line)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><ul><li>最后，根据 <code>show</code> 参数判断是否立即打印输出结果。如果 <code>show</code> 为 True，则逐行打印结果；如果 <code>show</code> 为 False，则返回结果列表。</li></ul><p>示例用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">data = <span class="hljs-string">b&#x27;Hello, world!\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f&#x27;</span><br>hexdump(data)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>C <span class="hljs-number">6</span>C <span class="hljs-number">6</span>F <span class="hljs-number">2</span>C <span class="hljs-number">20</span> <span class="hljs-number">77</span> <span class="hljs-number">6</span>F <span class="hljs-number">72</span> <span class="hljs-number">6</span>C <span class="hljs-number">64</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">02</span> Hello, world!...<br><span class="hljs-attribute">0010</span> <span class="hljs-number">03</span> <span class="hljs-number">04</span> <span class="hljs-number">05</span> <span class="hljs-number">06</span> <span class="hljs-number">07</span> <span class="hljs-number">08</span> <span class="hljs-number">09</span> <span class="hljs-number">0</span>A <span class="hljs-number">0</span>B <span class="hljs-number">0</span>C <span class="hljs-number">0</span>D <span class="hljs-number">0</span>E <span class="hljs-number">0</span>F         ..............<br></code></pre></td></tr></table></figure><p>这个例子中，我们调用 <code>hexdump</code> 函数打印了一个包含 ASCII 和非 ASCII 字符的字节对象的内容。输出结果按每行 16 个字节进行划分，并分别显示了十六进制和 ASCII 可打印字符的表示。</p><h3 id="代码块2-receive-from函数"><a href="#代码块2-receive-from函数" class="headerlink" title="代码块2 receive_from函数"></a>代码块2 receive_from函数</h3><p>这段代码定义了一个函数 <code>receive_from(connection)</code>，用于从给定的连接中接收数据，并将接收到的数据存储在缓冲区中，最后返回缓冲区中的数据。</p><p>让我解释一下这个函数的主要逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">receive_from</span>(<span class="hljs-params">connection</span>):<br>    buffer = <span class="hljs-string">b&quot;&quot;</span>  <span class="hljs-comment"># 创建一个字节字符串用于存储接收到的数据</span><br>    connection.settimeout(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 设置连接的超时时间为 5 秒</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data = connection.recv(<span class="hljs-number">4096</span>)  <span class="hljs-comment"># 接收最多 4096 字节的数据</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 如果没有数据接收到，退出循环</span><br>            buffer += data  <span class="hljs-comment"># 将接收到的数据追加到缓冲区</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 发生异常时不做处理</span><br>    <span class="hljs-keyword">return</span> buffer  <span class="hljs-comment"># 返回缓冲区中的数据</span><br></code></pre></td></tr></table></figure><p>这个函数主要有以下步骤：</p><ol><li><p>创建一个字节字符串 <code>buffer</code>，用于存储接收到的数据。</p></li><li><p>使用 <code>connection.settimeout(5)</code> 设置连接的超时时间为 5 秒，即如果在 5 秒内没有数据可接收，会引发超时异常。</p></li><li><p>使用 <code>while True:</code> 进入一个无限循环，不断尝试接收数据。</p></li><li><p>在循环中，使用 <code>connection.recv(4096)</code> 从连接中接收最多 4096 字节的数据。如果接收到的数据为空，表示连接已关闭，退出循环。</p></li><li><p>将接收到的数据追加到 <code>buffer</code> 中。</p></li><li><p>使用 <code>except Exception as e:</code> 捕获任何可能发生的异常，不做处理。</p></li><li><p>最后，函数返回存储在 <code>buffer</code> 中的所有接收到的数据。</p></li></ol><p>这个函数的目的是从连接中连续接收数据，直到连接关闭，然后将接收到的数据返回。在网络编程中，经常需要从连接中接收数据，这个函数提供了一个方便的方法来实现这一操作。</p><h3 id="代码块3-proxy-handler函数"><a href="#代码块3-proxy-handler函数" class="headerlink" title="代码块3 proxy_handler函数"></a>代码块3 proxy_handler函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">request_handler</span>(<span class="hljs-params">buffer</span>):<br>    <span class="hljs-keyword">return</span> buffer<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">response_handler</span>(<span class="hljs-params">buffer</span>):<br>    <span class="hljs-keyword">return</span> buffer<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">proxy_handler</span>(<span class="hljs-params">client_socket, remote_host, remote_port, receive_first</span>):<br>    remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    remote_socket.connect((remote_host, remote_port))<br><br>    <span class="hljs-keyword">if</span> receive_first:<br>        remote_buffer = receive_from(remote_socket)<br>        hexdump(remote_buffer)<br><br>    remote_buffer = response_handler(remote_buffer)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(remote_buffer):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&lt;==] Sending %d bytes to localhost.&quot;</span> % <span class="hljs-built_in">len</span>(remote_buffer))<br>        client_socket.send(remote_buffer)<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        local_buffer = receive_from(client_socket)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(local_buffer):<br>            line = <span class="hljs-string">&quot;[==&gt;]Received %d bytes from localhost.&quot;</span> % <span class="hljs-built_in">len</span>(local_buffer)<br>            <span class="hljs-built_in">print</span>(line)<br>            hexdump(local_buffer)<br>            <br>            local_buffer = request_handler(local_buffer)<br>            remote_socket.send(local_buffer)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[==&gt;] Sent to remote.&quot;</span>)<br>            <br>        remote_buffer = request_handler(local_buffer)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(remote_buffer):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&lt;==] Received %d bytes from remote.&quot;</span> % <span class="hljs-built_in">len</span>(remote_buffer))<br>            hexdump(remote_buffer)<br>            <br>            remote_buffer = response_handler(remote_buffer)<br>            client_socket.send(remote_buffer)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&lt;==] Sent to localhost.&quot;</span>)<br>            <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(local_buffer) <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(remote_buffer):<br>            client_socket.close()<br>            remote_socket.close()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] No more data. Closing connections.&quot;</span>)<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>这段代码是一个代理服务器处理程序，负责将客户端的数据转发到远程服务器，然后将远程服务器的响应返回给客户端。让我对每个部分进行解释：</p><ol><li><p><code>proxy_handler(client_socket, remote_host, remote_port, receive_first)</code>：这是代理服务器的处理函数。它接受客户端套接字、远程主机、远程端口和 <code>receive_first</code> 参数。</p></li><li><p><code>remote_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</code>：创建一个与远程服务器通信的套接字。</p></li><li><p><code>remote_socket.connect((remote_host, remote_port))</code>：建立与远程服务器的连接。</p></li><li><p><code>if receive_first:</code>：如果 <code>receive_first</code> 为 <code>True</code>，表示需要在发送数据之前先接收一些数据。</p><ul><li><code>remote_buffer = receive_from(remote_socket)</code>：从远程服务器接收数据。</li><li><code>hexdump(remote_buffer)</code>：使用之前定义的 <code>hexdump</code> 函数来打印接收到的数据。</li></ul></li><li><p><code>remote_buffer = response_handler(remote_buffer)</code>：对从远程服务器接收到的数据进行处理。</p></li><li><p><code>if len(remote_buffer):</code>：如果处理后的远程数据长度不为零。</p><ul><li><code>client_socket.send(remote_buffer)</code>：将处理后的数据发送回客户端。</li></ul></li><li><p>进入一个无限循环，循环处理客户端和远程服务器的数据。</p><ul><li><p><code>local_buffer = receive_from(client_socket)</code>：从客户端接收数据。</p></li><li><p><code>local_buffer = request_handler(local_buffer)</code>：对从客户端接收到的数据进行处理。</p></li><li><p><code>remote_socket.send(local_buffer)</code>：将处理后的客户端数据发送到远程服务器。</p></li><li><p><code>remote_buffer = request_handler(local_buffer)</code>：对从客户端发送到远程服务器的数据进行处理。</p></li><li><p><code>if len(remote_buffer):</code>：如果处理后的远程响应数据长度不为零。</p><ul><li><code>client_socket.send(remote_buffer)</code>：将处理后的响应数据发送回客户端。</li></ul></li></ul></li><li><p>如果没有数据可接收（无论是客户端还是远程服务器），关闭客户端和远程套接字，然后结束循环。</p></li></ol><p>这个代理服务器处理程序的目的是将客户端和远程服务器之间的数据进行中转，同时可以根据需要对数据进行处理。这是一个简单的示例，实际应用中可能需要更多的错误处理和安全性考虑。</p><h3 id="代码块4-server-loop函数"><a href="#代码块4-server-loop函数" class="headerlink" title="代码块4 server_loop函数"></a>代码块4 server_loop函数</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>py函数</title>
    <link href="/2023/07/20/py%E5%87%BD%E6%95%B0/"/>
    <url>/2023/07/20/py%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-一些标准库"><a href="#1-一些标准库" class="headerlink" title="1 一些标准库"></a>1 一些标准库</h1><h2 id="1-1-threading"><a href="#1-1-threading" class="headerlink" title="1.1 threading"></a>1.1 threading</h2><p><code>threading</code> 是 Python 标准库中用于实现多线程编程的模块。它提供了创建和管理线程的功能，使你能够在同一个程序中并发地执行多个任务。</p><p>使用 <code>threading</code> 模块，你可以轻松创建多个线程，每个线程可以执行不同的任务，从而提高程序的并发性和响应性。以下是一些常见的 <code>threading</code> 模块的用法：</p><ol><li><p>创建线程：<br>使用 <code>threading.Thread</code> 类可以创建一个新的线程，你需要将要执行的函数作为参数传递给它。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_function</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello from a thread!&quot;</span>)<br><br>my_thread = threading.Thread(target=my_function)<br></code></pre></td></tr></table></figure></li><li><p>启动线程：<br>使用 <code>start()</code> 方法来启动线程，它将开始执行你传递的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_thread.start()<br></code></pre></td></tr></table></figure></li><li><p>等待线程完成：<br>使用 <code>join()</code> 方法可以等待线程执行完成，然后再继续执行主线程的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_thread.join()<br></code></pre></td></tr></table></figure></li><li><p>线程锁（Lock）：<br>在多线程环境中，可能会出现多个线程访问共享资源的问题。使用线程锁可以防止多个线程同时修改共享资源，从而避免竞争条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br>lock = threading.Lock()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">modify_shared_resource</span>():<br>    <span class="hljs-keyword">with</span> lock:<br>        <span class="hljs-comment"># 修改共享资源的代码</span><br></code></pre></td></tr></table></figure></li><li><p>其他功能：<br><code>threading</code> 模块还提供了其他一些功能，如定时器、信号量、条件变量等，用于更复杂的多线程编程。</p></li></ol><p>当你使用 <code>threading.Thread</code> 创建一个新线程时，你需要传递一个函数作为 <code>target</code> 参数，这个函数将在新线程中执行。如果这个函数需要参数，你可以使用 <code>args</code> 参数来传递这些参数。以下是一个简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_numbers</span>(<span class="hljs-params">start, end</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, end + <span class="hljs-number">1</span>):<br>        <span class="hljs-built_in">print</span>(i)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_letters</span>():<br>    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(letter)<br><br><span class="hljs-comment"># 创建两个线程，一个打印数字，一个打印字母</span><br>number_thread = threading.Thread(target=print_numbers, args=(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br>letter_thread = threading.Thread(target=print_letters)<br><br><span class="hljs-comment"># 启动线程</span><br>number_thread.start()<br>letter_thread.start()<br><br><span class="hljs-comment"># 等待两个线程执行完成</span><br>number_thread.join()<br>letter_thread.join()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Both threads have finished.&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了两个函数 <code>print_numbers</code> 和 <code>print_letters</code>，分别用于打印数字和字母。然后，我们使用 <code>threading.Thread</code> 创建了两个线程，分别传递这两个函数作为 <code>target</code> 参数。<code>print_numbers</code> 函数需要 <code>start</code> 和 <code>end</code> 参数，我们使用 <code>args</code> 参数将这些参数传递给函数。</p><p>接着，我们分别启动这两个线程，并使用 <code>join()</code> 方法等待它们执行完成。最后，我们输出 “Both threads have finished.” 来表示两个线程都已经完成了执行。</p><h2 id="1-2-Socket常用函数接口及其原理"><a href="#1-2-Socket常用函数接口及其原理" class="headerlink" title="1.2 Socket常用函数接口及其原理"></a>1.2 Socket常用函数接口及其原理</h2><p><img src="https://aliyun-picgo-img.oss-cn-hangzhou.aliyuncs.com/img/image-20230814174402437.png" alt="image-20230814174402437"></p><p>client</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br>target_host = <span class="hljs-string">&quot;192.168.233.129&quot;</span><br>target_port = <span class="hljs-number">6666</span><br><br><span class="hljs-comment"># create a socket object</span><br>client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br><span class="hljs-comment"># connect the client</span><br>client.connect((target_host, target_port))<br><br><span class="hljs-comment"># send some data</span><br>client.send(<span class="hljs-string">b&quot;GET / HTTP/1.1\r\nHost: google.com\r\n\r\n&quot;</span>)<br><br>response = client.recv(<span class="hljs-number">4096</span>)<br><br><span class="hljs-built_in">print</span>(response.decode())<br>client.close()<br></code></pre></td></tr></table></figure><p>server</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">listen_port</span>():<br>    listen_ip = <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>  <span class="hljs-comment"># 监听所有可用接口</span><br>    listen_port = <span class="hljs-number">6666</span>  <span class="hljs-comment"># 监听端口号</span><br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 创建一个TCP套接字</span><br>        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br><br>        <span class="hljs-comment"># 绑定到指定地址和端口</span><br>        server_socket.bind((listen_ip, listen_port))<br><br>        <span class="hljs-comment"># 开始监听</span><br>        server_socket.listen(<span class="hljs-number">1</span>)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在监听端口 <span class="hljs-subst">&#123;listen_port&#125;</span> ...&quot;</span>)<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 等待客户端连接</span><br>            client_socket, client_address = server_socket.accept()<br><br>            <span class="hljs-comment"># 接收数据</span><br>            data = client_socket.recv(<span class="hljs-number">1024</span>).decode()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;接收到来自 <span class="hljs-subst">&#123;client_address[<span class="hljs-number">0</span>]&#125;</span> 的数据：<span class="hljs-subst">&#123;data&#125;</span>&quot;</span>)<br><br>            <span class="hljs-comment"># 关闭与客户端的连接</span><br>            client_socket.close()<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;监听端口时出错：<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    listen_port()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
